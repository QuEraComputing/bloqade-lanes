from dataclasses import dataclass
import math

from bloqade.analysis.fidelity import FidelityAnalysis, FidelityRange
from kirin import ir

from bloqade.lanes.analysis.placement.strategy import PlacementStrategyABC
from bloqade.lanes.dialects import move
from bloqade.lanes.arch.gemini import logical
from bloqade.lanes.arch.gemini.impls import generate_arch_hypercube
from bloqade.lanes.heuristics import fixed
from bloqade.lanes.logical_mvp import transversal_rewrites
from bloqade.lanes.noise_model import generate_simple_noise_model
from bloqade.lanes.rewrite.move2squin.noise import NoiseModelABC
from bloqade.lanes.transform import MoveToSquin
from bloqade.lanes.upstream import (
    default_merge_heuristic,
    squin_to_move,
)


@dataclass(frozen=True)
class KernelFidelityMetrics:
    """Fidelity metrics computed from a physical noisy SQuin kernel."""

    gate_fidelities: list[float]
    gate_fidelity_product: float


@dataclass(frozen=True)
class KernelMoveMetrics:
    """Move metadata computed from a compiled Move kernel."""

    approx_lane_parallelism: float
    moved_lane_count: int


@dataclass(frozen=True)
class MoveTimeEvent:
    """Per-move event timing details in microseconds."""

    event_index: int
    lane_count: int
    move_type: str
    bus_id: int
    direction: str
    lane_durations_us: list[float]
    event_duration_us: float
    segment_distances_um: list[float]
    segment_durations_us: list[float]
    pick_time_us: float
    drop_time_us: float
    timing_model: str


@dataclass(frozen=True)
class KernelMoveTimeMetrics:
    """Move timing metrics computed from a compiled Move kernel."""

    total_move_time_us: float
    events: list[MoveTimeEvent]
    timing_model: str


# Hard-extracted from bloqade-flair: bloqade-flair/src/bloqade/flair/upstream/lanes/lib/config.py
_EXTRACTED_FLAIR_MAX_RAMP = 0.2
_EXTRACTED_FLAIR_MAX_JERK = 0.0004
_EXTRACTED_FLAIR_MAX_ACCEL = 0.0015


def _collapse_range(fidelity: FidelityRange) -> float:
    # Use the conservative lower bound.
    return fidelity.min


def _product_fidelity(fidelities: list[float]) -> float:
    product = 1.0
    for fidelity in fidelities:
        product *= fidelity
    return product


def _count_move_events_and_lanes(move_mt: ir.Method) -> tuple[int, int]:
    move_event_count = 0
    moved_lane_count = 0

    for stmt in move_mt.callable_region.walk():
        if isinstance(stmt, move.Move):
            move_event_count += 1
            moved_lane_count += len(stmt.lanes)

    return move_event_count, moved_lane_count


def _compute_approx_lane_parallelism(move_event_count: int, moved_lane_count: int) -> float:
    if move_event_count == 0:
        return 0.0
    return moved_lane_count / move_event_count


def _path_segment_distances_um(path: tuple[tuple[float, float], ...]) -> list[float]:
    # Distances are derived from consecutive waypoints in arch_spec.get_path(lane).
    # get_path reads precomputed lane path segments generated by
    # generate_arch_hypercube(...) in arch/gemini/impls.py.
    # Segment length uses max(|dx|, |dy|) to match lane motion.
    if len(path) <= 1:
        return []

    out: list[float] = []
    for (x0, y0), (x1, y1) in zip(path, path[1:]):
        out.append(max(abs(x1 - x0), abs(y1 - y0)))
    return out


def _compute_event_duration_us(lane_durations_us: list[float]) -> float:
    if len(lane_durations_us) == 0:
        return 0.0
    return max(lane_durations_us)


def _compute_const_jerk_min_dur_extracted(
    max_dist: float,
    *,
    max_accel: float,
    max_jerk: float,
) -> float:
    """Equivalent scalar form of flair's compute_const_jerk_min_dur. 
    Idea is t1 time is ramp up time to max abs accel, t2 is hold time at max abs accel."""
    max_dist = abs(max_dist)
    if max_dist < 1e-8:
        return 0.0

    t1 = max_accel / max_jerk
    a = max_jerk * t1
    b = 3 * max_jerk * t1**2
    c = 2 * max_jerk * t1**3 - max_dist
    if c >= 0:
        t1_jerk = (max_dist / (2 * max_jerk)) ** (1 / 3)
        return 4 * t1_jerk

    discriminant = b**2 - 4 * a * c
    t2 = (-b + math.sqrt(discriminant)) / (2 * a)
    return 4 * t1 + 2 * t2


def _compute_lane_duration_with_extracted_flair(
    segment_distances_um: list[float],
    *,
    amplitude_delta: float,
) -> tuple[list[float], float, float, float]:
    # Core timing constants are hard-extracted from bloqade-flair
    # (MAX_RAMP, MAX_ACCEL, MAX_JERK). Each segment duration is computed with
    # the flair-extracted minimum-duration formula, then we
    # add symmetric pick/drop ramp times based on amplitude_delta / MAX_RAMP.
    segment_durations_us = [
        _compute_const_jerk_min_dur_extracted(
            max_dist=distance_um,
            max_accel=_EXTRACTED_FLAIR_MAX_ACCEL,
            max_jerk=_EXTRACTED_FLAIR_MAX_JERK,
        )
        for distance_um in segment_distances_um
    ]
    # Derived from flair's linear_amplitude_impl
    #amplitude delta is 1.0 based on bloqade-flair/src/bloqade/flair/stdlib/kernel_maker/move.py's ramp_on_aod_x
    ramp_time_us = abs(amplitude_delta) / _EXTRACTED_FLAIR_MAX_RAMP
    lane_duration_us = ramp_time_us + sum(segment_durations_us) + ramp_time_us
    return segment_durations_us, ramp_time_us, ramp_time_us, lane_duration_us


def _compile_kernel_to_noisy_physical_squin(
    mt: ir.Method,
    *,
    placement_strategy: PlacementStrategyABC,
    insert_palindrome_moves: bool,
    merge_heuristic=default_merge_heuristic,
    noise_model: NoiseModelABC | None = None,
) -> ir.Method:
    if noise_model is None:
        noise_model = generate_simple_noise_model()

    move_mt = squin_to_move(
        mt,
        layout_heuristic=fixed.LogicalLayoutHeuristic(),
        placement_strategy=placement_strategy,
        insert_palindrome_moves=insert_palindrome_moves,
        merge_heuristic=merge_heuristic,
    )
    move_mt = transversal_rewrites(move_mt)
    transformer = MoveToSquin(
        arch_spec=generate_arch_hypercube(4),
        logical_initialization=logical.steane7_initialize,
        noise_model=noise_model,
        aggressive_unroll=False,
    )
    return transformer.emit(move_mt)

def _analyze_move_time_from_move_ir(
    move_mt: ir.Method,
    *,
    flair_amplitude_delta: float,
) -> KernelMoveTimeMetrics:
    arch_spec = generate_arch_hypercube(4)
    events: list[MoveTimeEvent] = []
    for event_index, stmt in enumerate(move_mt.callable_region.walk()):
        if not isinstance(stmt, move.Move):
            continue

        lane_durations_us: list[float] = []
        lane_segment_distances_um: list[list[float]] = []
        lane_segment_durations_us: list[list[float]] = []
        lane_pick_times_us: list[float] = []
        lane_drop_times_us: list[float] = []

        for lane in stmt.lanes:
            path = arch_spec.get_path(lane)
            segment_distances_um = _path_segment_distances_um(path)
            (
                segment_durations_us,
                pick_time_us,
                drop_time_us,
                lane_duration_us,
            ) = _compute_lane_duration_with_extracted_flair(
                segment_distances_um,
                amplitude_delta=flair_amplitude_delta,
            )
            timing_model = "flair_extracted_const_jerk"

            lane_durations_us.append(lane_duration_us)
            lane_segment_distances_um.append(segment_distances_um)
            lane_segment_durations_us.append(segment_durations_us)
            lane_pick_times_us.append(pick_time_us)
            lane_drop_times_us.append(drop_time_us)

        event_duration_us = _compute_event_duration_us(lane_durations_us)

        rep_index = max(range(len(lane_durations_us)), key=lane_durations_us.__getitem__)
        rep_lane = stmt.lanes[rep_index]
        events.append(
            MoveTimeEvent(
                event_index=event_index,
                lane_count=len(stmt.lanes),
                move_type=rep_lane.move_type.name,
                bus_id=rep_lane.bus_id,
                direction=rep_lane.direction.name,
                lane_durations_us=lane_durations_us,
                event_duration_us=event_duration_us,
                segment_distances_um=lane_segment_distances_um[rep_index],
                segment_durations_us=lane_segment_durations_us[rep_index],
                pick_time_us=lane_pick_times_us[rep_index],
                drop_time_us=lane_drop_times_us[rep_index],
                timing_model=timing_model,
            )
        )

    timing_model = "flair_extracted_const_jerk"
    total_move_time_us = sum(event.event_duration_us for event in events)
    return KernelMoveTimeMetrics(
        total_move_time_us=total_move_time_us,
        events=events,
        timing_model=timing_model,
    )


def analyze_kernel_fidelity_with_strategy(
    mt: ir.Method,
    *,
    placement_strategy: PlacementStrategyABC,
    insert_palindrome_moves: bool,
    merge_heuristic=default_merge_heuristic,
    noise_model: NoiseModelABC | None = None,
) -> KernelFidelityMetrics:
    """
    Analyze approximate fidelity for a logical SQuin kernel with explicit strategy control.

    The kernel is compiled through the lanes pipeline:
    logical SQuin -> move -> physical noisy SQuin. The resulting physical kernel
    is then passed to ``FidelityAnalysis`` from ``bloqade-circuit``.

    We intentionally report only pauli gate (XYZ) fidelities for now. With the
    current GeminiNoiseModelABC defaults, all loss probabilities are 0. The reported gate
    fidelity includes non-loss errors from moves, idling, and CZ-unpaired noise.
    If upstream returns a fidelity range, this uses the conservative lower.
    """
    physical_squin = _compile_kernel_to_noisy_physical_squin(
        mt,
        placement_strategy=placement_strategy,
        insert_palindrome_moves=insert_palindrome_moves,
        merge_heuristic=merge_heuristic,
        noise_model=noise_model,
    )
    analysis = FidelityAnalysis(physical_squin.dialects)
    analysis.run(physical_squin)
    gate_fidelities = [_collapse_range(fid) for fid in analysis.gate_fidelities]
    return KernelFidelityMetrics(
        gate_fidelities=gate_fidelities,
        gate_fidelity_product=_product_fidelity(gate_fidelities),
    )


def analyze_kernel_moves_with_strategy(
    mt: ir.Method,
    *,
    placement_strategy: PlacementStrategyABC,
    insert_palindrome_moves: bool,
    merge_heuristic=default_merge_heuristic,
) -> KernelMoveMetrics:
    """
    Analyze move-count metadata with explicit move-compilation strategy control.

    The kernel is compiled to Move IR and then scanned for ``move.Move``
    statements. We report:
    - ``approx_lane_parallelism`` = moved_lane_count / move_event_count
    - ``moved_lane_count`` = total lanes carried by all move events
    """
    move_mt = squin_to_move(
        mt,
        layout_heuristic=fixed.LogicalLayoutHeuristic(),
        placement_strategy=placement_strategy,
        insert_palindrome_moves=insert_palindrome_moves,
        merge_heuristic=merge_heuristic,
    )
    move_event_count, moved_lane_count = _count_move_events_and_lanes(move_mt)
    return KernelMoveMetrics(
        approx_lane_parallelism=_compute_approx_lane_parallelism(
            move_event_count, moved_lane_count
        ),
        moved_lane_count=moved_lane_count,
    )


def analyze_kernel_move_time_with_strategy(
    mt: ir.Method,
    *,
    placement_strategy: PlacementStrategyABC,
    insert_palindrome_moves: bool,
    merge_heuristic=default_merge_heuristic,
    flair_amplitude_delta: float = 1.0,
) -> KernelMoveTimeMetrics:
    """
    Analyze move-time metadata with explicit move-compilation strategy control.

    The kernel is compiled to Move IR and each ``move.Move`` statement is
    treated as one move event. Lane durations inside an event are evaluated
    independently, and event duration is the maximum lane duration.

    Distances come from architecture lane paths returned by ``ArchSpec.get_path``
    (Gemini hypercube lane polylines); each path segment contributes
    ``max(|dx|, |dy|)`` microns. Durations use extracted flair
    constant-jerk formulas + pick/drop ramp terms.
    """
    move_mt = squin_to_move(
        mt,
        layout_heuristic=fixed.LogicalLayoutHeuristic(),
        placement_strategy=placement_strategy,
        insert_palindrome_moves=insert_palindrome_moves,
        merge_heuristic=merge_heuristic,
    )
    return _analyze_move_time_from_move_ir(
        move_mt,
        flair_amplitude_delta=flair_amplitude_delta,
    )
